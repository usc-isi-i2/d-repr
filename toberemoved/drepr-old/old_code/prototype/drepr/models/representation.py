from typing import Iterable, List, Dict

from drepr.mfunc.mapping_graph import MappingGraph
from drepr.misc.class_helper import Equal
from drepr.misc.dict2instance import Dict2InstanceDeSer, get_object_list_deser, get_object_enum_deser, \
    get_object_map_deser
from drepr.exceptions import InvalidReprException
from drepr.models.parser_v1 import ReprReadableDeSerV1
from drepr.models.variable import Variable
from drepr.models.mapping import Mapping, DimensionMapping
from drepr.models.preprocessing import TransformFunc
from drepr.models.resource import Resource, ResourceDeSer
from drepr.models.semantic_model import SemanticModel


class Representation(Dict2InstanceDeSer, Equal):
    DeserializeErrorClass = InvalidReprException
    class_properties = {
        "resources": get_object_map_deser("resources", ResourceDeSer),
        "layout": get_object_map_deser("layout", Variable, add_key_as_prop="id"),
        "preprocessing": get_object_list_deser("preprocessing", TransformFunc),
        "mappings": get_object_list_deser(
            "mappings", get_object_enum_deser({
                "dimension_mapping": DimensionMapping,
            })),
        "semantic_model": SemanticModel,
    }
    class_rename_props = {"layout": "variables"}

    def __init__(self, resources: Dict[str, Resource], variables: Dict[str, Variable],
                 preprocessing: List[TransformFunc], mappings: List[Mapping],
                 semantic_model: SemanticModel) -> None:
        self.resources = resources
        self.variables = variables
        self.preprocessing = preprocessing
        self.mappings = mappings
        self.semantic_model = semantic_model

    @staticmethod
    def default():
        return Representation({}, {}, [], [], SemanticModel({}, [], {}))

    @staticmethod
    def parse(o: dict):
        if not isinstance(o, dict):
            raise InvalidReprException("Invalid serialized data representation. Expect a map")

        version = str(o.pop('version', 'latest'))
        if version in {'1', 'latest'}:
            repr = Representation(**ReprReadableDeSerV1.unsafe_deserialize(o).args)
            Representation.post_deserialize(repr)
            return repr

        raise InvalidReprException("Invalid version")

    def validate(self) -> bool:
        raise NotImplementedError()

    def add_resource(self, resource: Resource):
        self.resources[resource.id] = resource

    def remove_resource(self, resource_id: str):
        self.resources.pop(resource_id)
        del_variables = []
        for var in self.variables.values():
            if var.location.resource_id == resource_id:
                del_variables.append(var.id)

        for vid in del_variables:
            self.del_variable(vid)

    def has_variable(self, var_id: str):
        return var_id in self.variables

    def upsert_variable(self, var: Variable):
        # id doesn't change so we just replace it
        self.variables[var.id] = var

    def del_variable(self, var_id: str):
        self.variables.pop(var_id)
        self.semantic_model.delete_data_node(var_id)
        self.mappings: List[Mapping] = [
            m for m in self.mappings
            if m.get_source_variable_id() == var_id and m.get_target_variable_id() == var_id
        ]

    def get_variable(self, var_id: str) -> Variable:
        return self.variables[var_id]

    def get_variables(self) -> Iterable[Variable]:
        """Return list of variables available in the datasets (including variables generated by preprocessing)"""
        return self.variables.values()

    def set_mappings(self, mappings: List[Mapping]):
        self.mappings = mappings

    def add_mapping(self, mapping: Mapping):
        self.mappings.append(mapping)

    def get_mapping_graph(self) -> 'MappingGraph':
        return MappingGraph(self)

    def set_semantic_model(self, sm: SemanticModel):
        self.semantic_model = sm
