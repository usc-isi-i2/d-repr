#!/usr/bin/python
"""
Execute command
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path


def get_pylib_ext():
    return {"linux": "so", "darwin": "so", "win32": "pyd"}[sys.platform]


def get_target_triple():
    return {
        "linux": "x86_64-unknown-linux-gnu",
        "darwin": "x86_64-apple-darwin",
        "win32": "x86_64-pc-windows-msvc"
    }[sys.platform]


def exc(py_wdir: str, ru_wdir: str, engine_version: str, target_triple: str, args: argparse.Namespace):
    py_wdir = os.path.abspath(py_wdir)
    ru_wdir = os.path.abspath(ru_wdir)

    lib_name = {"linux": "libengine.so", "darwin": "libengine.dylib", "win32": "engine.dll"}[sys.platform]
    pylib_ext = get_pylib_ext()

    cargo_build_mode = ""
    if args.build_mode != "debug":
        cargo_build_mode = f"--{args.build_mode}"

    if args.cmd == "pylib-build":
        subprocess.check_call(
            f"cargo build {cargo_build_mode} --lib --target={target_triple} --features cpython/extension-module",
            cwd=os.path.join(ru_wdir, "engine"),
            shell=True)

        # copy for development
        shutil.copyfile(
            Path(ru_wdir) / f"target/{target_triple}/{args.build_mode}/{lib_name}",
            Path(py_wdir) / f"drepr/drepr_engine.{pylib_ext}")
        return

    if args.cmd == "pylib-release":
        shutil.copyfile(
            Path(ru_wdir) / f"target/{target_triple}/{args.build_mode}/{lib_name}",
            Path(ru_wdir) / f"target/drepr_engine.{target_triple}.{engine_version}.{pylib_ext}")
        return

    raise Exception("Invalid cmd")


if __name__ == "__main__":
    py_wdir = os.path.dirname(os.path.abspath(__file__))
    ru_wdir = os.path.join(py_wdir, "..", "drepr")
    target_triple = get_target_triple()

    parser = argparse.ArgumentParser()
    parser.add_argument("cmd",
                        choices=["pylib-build", "pylib-release", "info"],
                        help="command to run")
    parser.add_argument("--build_mode",
                        "-m",
                        choices=["debug", "release"],
                        default="debug",
                        help="build mode")
    parser.add_argument("--pre_built_engine_location",
                        action="store_true",
                        default=False,
                        help="Get location of the pre-built engine file (only work with `info` command)")
    parser.add_argument("--pre_built_engine_glob",
                        action="store_true",
                        default=False,
                        help="Get a glob rule that matches all pre-built engine files (only work with `info` command)")
    parser.add_argument("--min_pylib_version_compatible_with_engine",
                        action="store_true",
                        default=False,
                        help="get the minimum version of python library that is compatible with the engine, i.e., the version of the python library at the time when the engine is updated (only work with `info` command)")

    args = parser.parse_args()

    # execute script to read the version
    exec(open(Path(py_wdir) / "drepr" / "version.py", "r").read())

    if args.cmd == "info":
        if args.pre_built_engine_location:
            engine_file = os.path.join(ru_wdir, "target", f"drepr_engine.{target_triple}.{__engine_version__}.{get_pylib_ext()}")
            print(os.path.abspath(engine_file))
        elif args.pre_built_engine_glob:
            engine_file = os.path.join(ru_wdir, "target", f"drepr_engine.*")
            print(os.path.abspath(engine_file))
        elif args.min_pylib_version_compatible_with_engine:
            print(__min_version_compatible_with_engine__)
    else:
        exc(py_wdir, ru_wdir, __engine_version__, target_triple, args)
